/*
 * AimMatic API
 * APIs for Natural Voice and placeNext
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client;

import com.aimmatic.auth.Signature;
import com.google.gson.*;
import com.google.gson.annotations.SerializedName;
import com.google.gson.internal.$Gson$Types;
import com.google.gson.internal.ConstructorConstructor;
import com.google.gson.internal.Excluder;
import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;
import com.google.gson.internal.bind.MapTypeAdapterFactory;
import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.auth.ApiKeyAuth;
import io.swagger.client.auth.Authentication;

import java.io.IOException;
import java.io.Writer;
import java.lang.reflect.Field;
import java.lang.reflect.Type;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.*;

/**
 * This class is override the generated class from Swagger
 */
public class Configuration {

    private static ApiClient defaultApiClient;
    private static Signature defaultSignature;

    static {
        defaultApiClient = new ApiClient();
        defaultSignature = new Signature();
        initializeApiClient(defaultApiClient);
    }

    private static void initializeApiClient(ApiClient apiClient) {
        Map<String, Authentication> auths = apiClient.getAuthentications();
        // There is a bugs on iterate in the method defaultApiClient.setApiKey(); so do our own iterator
        for (String key : auths.keySet()) {
            Authentication auth = auths.get(key);
            if (auth instanceof ApiKeyAuth) {
                ((ApiKeyAuth) auth).setApiKey("aimmatic");
            }
        }
        apiClient.getHttpClient().networkInterceptors().add(defaultSignature);
        // this code should remove when 1 years old issue (https://github.com/swagger-api/swagger-codegen/issues/5187)
        // is resolved.
        apiClient.getJSON().setGson(new GsonBuilder()
                // copied generate from the code
                .registerTypeAdapter(Date.class, new DateAdapter(apiClient))
                .registerTypeAdapter(OffsetDateTime.class, new OffsetDateTimeTypeAdapter())
                .registerTypeAdapter(LocalDate.class, new LocalDateTypeAdapter())
                // new custom to handle such class io.swagger.client.model.ArbitraryDocWithLatLong
                .registerTypeAdapterFactory(new CustomExtendedMapAdapterFactory())
                .create());
    }

    public static Signature getDefaultSignature() {
        return defaultSignature;
    }

    /**
     * Get the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @return Default API client
     */
    public static ApiClient getDefaultApiClient() {
        return defaultApiClient;
    }

    /**
     * Set the default API client, which would be used when creating API
     * instances without providing an API client.
     *
     * @param apiClient API client
     */
    public static void setDefaultApiClient(ApiClient apiClient) {
        defaultApiClient = apiClient;
        initializeApiClient(defaultApiClient);
    }
}

/**
 * Custom adapter factory to resolve JSON encode that which is not include object's field when
 * class itself extended from Map
 */
class CustomExtendedMapAdapterFactory implements TypeAdapterFactory {

    MapTypeAdapterFactory defaultMapFactory;
    ReflectiveTypeAdapterFactory defaultObjectFactory;

    CustomExtendedMapAdapterFactory() {
        ConstructorConstructor constructorConstructor = new ConstructorConstructor(Collections.<Type, InstanceCreator<?>>emptyMap());
        defaultMapFactory = new MapTypeAdapterFactory(constructorConstructor, false);
        defaultObjectFactory = new ReflectiveTypeAdapterFactory(constructorConstructor,
                FieldNamingPolicy.IDENTITY, Excluder.DEFAULT,
                new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));
    }

    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
        if (type.getRawType().getSuperclass() != HashMap.class) {
            return null;
        }
        final TypeAdapter<T> mapAdapter = defaultMapFactory.create(gson, type);
        if (mapAdapter != null) {
            TypeAdapter<T> adapter = defaultObjectFactory.create(gson, type);
            Map<String, Field> objectField = new HashMap<>();
            TypeToken<?> cType = type;
            Class<?> raw = cType.getRawType();
            while (raw != Object.class) {
                Field[] fields = raw.getDeclaredFields();
                for (Field field : fields) {
                    boolean serialize = defaultObjectFactory.excludeField(field, true);
                    if (serialize) {
                        field.setAccessible(true);
                        SerializedName annotation = field.getAnnotation(SerializedName.class);
                        // relied on Swagger generated code always include SerializedName annotation
                        // otherwise field will not included
                        if (annotation != null) {
                            objectField.put(annotation.value(), field);
                        }
                    }
                }
                cType = TypeToken.get($Gson$Types.resolve(cType.getType(), raw, raw.getGenericSuperclass()));
                raw = cType.getRawType();
            }
            return (TypeAdapter<T>) new CustomExtendedMapAdapter(mapAdapter, adapter, objectField);
        }
        return mapAdapter;
    }

    class CustomExtendedMapAdapter extends TypeAdapter<Map<String, Object>> {
        TypeAdapter<Map<String, Object>> mapAdapter;
        TypeAdapter<Map<String, Object>> objectAdapter;
        Map<String, Field> objectField;

        CustomExtendedMapAdapter(TypeAdapter mapAdapter, TypeAdapter objectAdapter, Map<String, Field> objectField) {
            this.mapAdapter = mapAdapter;
            this.objectAdapter = objectAdapter;
            this.objectField = objectField;
        }

        @Override
        public void write(final JsonWriter out, Map<String, Object> value) throws IOException {
            Object va1 = value;
            value = new LinkedHashMap<>(value);
            for (String key : objectField.keySet()) {
                try {
                    value.put(key, objectField.get(key).get(va1));
                } catch (IllegalAccessException e) {
                    throw new IllegalStateException("cannot get value from field " + key);
                }
            }
            mapAdapter.write(out, value);
        }

        @Override
        public Map<String, Object> read(JsonReader in) throws IOException {
            Map<String, Object> map = mapAdapter.read(in);
            Map<String, Object> object = objectAdapter.fromJsonTree(mapAdapter.toJsonTree(map));
            object.putAll(map);
            return object;
        }
    }
}

class JsonWriterWrapper extends JsonWriter {
    public JsonWriterWrapper(Writer out) {
        super(out);
    }
}

